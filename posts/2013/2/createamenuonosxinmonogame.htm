
        <p>One of the big differences between OSX and Windows is that in Windows every window has it&rsquo;s own menu bar (the place where you find File, Edit, Help, etc.) while on OSX there&rsquo;s a system controlled one that an application can add their items to. (There are other difference but the only ones that matter for here.) In most OSX applications you configure this from Interface Builder (even in MonoMac) for your windows. In MonoGame though you can&rsquo;t really do this.</p>
        <p>To do this in MonoGame you have to do some things that are very weird and very order dependent.</p>
        <p>In you LoadContent Method you must first have the following code:</p>
        <p><code class="text/x-csharp">NSApplication.SharedApplication.Menu = new NSMenu();<br />var appMenu = new NSMenuItem();<br />NSApplication.SharedApplication.MainMenu.AddItem(appMenu);<br />appMenu.Submenu = new NSMenu();</code></p>
        <p> The code first tells OSX that we will be creating a the menu so we replace the default menu bar with our own. Now even though we have created our own menu bar OSX still adds a default implementation of the application&rsquo;s menu (the menu that has your applications name). Weirdly instead of allowing you to access it via some method/property and then any new menus you add being created after it the first menu item you add becomes the application menu item and every item after that is added after the application menu. You&rsquo;ll note that we don&rsquo;t set a title for the menu anywhere, OSX automatically sets it for us.</p>
        <p>To add items to the application menu you add NSMenuItems to appMenu.Submenu like so:</p>
        <p><code class="text/x-csharp">appMenu.Submenu.AddItem(new NSMenuItem("New"));<br />appMenu.Submenu.AddItem(new NSMenuItem("Open"));<br />appMenu.Submenu.AddItem(new NSMenuItem("Save"));</code></p>
        <p>If you want to add another menu item to the menu you do:</p>
        <p><code class="text/x-csharp">var appMenu2 = new NSMenuItem();<br />NSApplication.SharedApplication.MainMenu.AddItem(appMenu2);<br />appMenu2.Submenu = new NSMenu("SubMenu2");</code></p>
        <p> And then you add items to it like you did the application&rsquo;s menu. You may have noticed that you use Submenu to set the name of the menu and it&rsquo;s sub items. No idea why but you do.</p>
        <p><strong>UPDATE</strong></p>
        <p>When I posted this I figured adding event handlers would be easy so no need to show how. PS I was wrong.</p>
        <p>For starters there are no event or such to listen to, instead you pass in a function of &ldquo;type&rdquo; EventHandler as the second argument to NSMenuItem. I would prefer if we could use the more .NET like event system but what can you do.</p>
        <p>A more interesting problem arises from the interactions between Mono and the Cocoa Framework underneath. Remember that Objective-C is NOT a Managed language and there is no Garbage Collector to not only collect out of scope object but to also smartly NOT collect objects that are still needed. This effects us in that if your NSMenuItem that you gave a function to so you would be told when it was selected goes out of scope your code will crash because the NSMenuItem was collected by the Mono GC. So if you&rsquo;re creating the menu&rsquo;s in a &ldquo;Menu creator function&rdquo; like I am, you can solve this problem by creating a member field that is of type LinkedList&lt;NSMenuItem&gt; and adding the NSMenuItems to it. (I use a LinkedList since it has faster appending speed and performance than a List and I don&rsquo;t need a List&rsquo;s access speed and performance since I never read the list.)</p>
      