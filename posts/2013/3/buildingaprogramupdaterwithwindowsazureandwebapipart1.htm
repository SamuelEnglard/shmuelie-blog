
        <p>In my current job one of the big requirements we had was to have a way to upgrade our uses with minimal fuss. After some research I decided to build my own system using Windows Azure and WebAPI. In this first post I&rsquo;m going to explain what we do and why we do it. In following posts I&rsquo;ll show some of the code I&rsquo;ve used (Can&rsquo;t show the exact code since it&rsquo;s proprietary).</p>
        <p>The update system I build is designed to be quick and simple for both developer and end user.</p>
        <ul><li>Updates are just the files that changed: Users don&rsquo;t have to re-download the whole program but developers don&rsquo;t need any fancy tools to create file diffs. A good trade off I think.</li>
        <li>Updating is done by the program it&rsquo;s self: Only one program to deploy and update.</li>
        <li>Updates are cumulative: Updater logic will update user to most recent no mater how old they are while the developer doesn&rsquo;t have to do anything special.</li>
        <li>More than one product can be stored in it.</li>
        <li>While I use Windows Azure any hosting plan with a Database and a file storage system will work.</li>
        </ul><h2>Server</h2>
        <h3>File Storage:</h3>
        <p>The updates are stored in a combination of SQL Server and Blob Storage. In the database we have two tables. The first stores the updates; their version number, the name of the product it belongs to, and an ID. The second contains a list of files in updates, linked to their update by the updates ID. Each file in the update has both the relative location on the client it belongs in and the location on the web it belongs to. In my implementation the location on the web is a Blob Storage URL.</p>
        <p>The files that are uploaded to the server should be separated first by their product and then by the version they belong to. By separating on the version too if a file is uploaded more than once and a problem is found with an update rolling back become much easier. I personally make the path on the server the same as the relative path on the client to help prevent name collisions with files.</p>
        <h3>WebAPI</h3>
        <p> To allow the program to access the server and get updates we use WebAPI. There only needs to be one method in the function that is given the product name and the client&rsquo;s current version. The method can then search if their are any versions greater than that in the database. If not it can return a 204. If it does find them it can build up a &ldquo;package&rdquo; for the client that includes all the changes between it&rsquo;s version and the most recent. How I do this will be explained later on.</p>
        <h2>Client</h2>
        <p> On the client to check for updates is very simple, we just call the WebAPI control and check the response code. Updating is a bit more complex. In my program I don&rsquo;t actually update the program till the user exits but there&rsquo;s no reason you have to wait but if you do not much extra data is sent over the wire since you don&rsquo;t send the files them selves, just links to where they are on the server (or in blob storage).</p>
        <p>When we are doing the actual updating we have to do some interesting tricks to get around two &ldquo;problems&rdquo;. The first problem is that you can&rsquo;t overwrite the programs files while they&rsquo;re in use. This we solve by using a renaming trick. The bases of the trick is that you can rename a in use file and the write a file with the old name. The second problem is that starting in Windows Vista the &ldquo;Program Files&rdquo; folder is write protected unless running with administrative rights. To get around this problem but stay in the goal of self updating we launch a second version of our self with a special command line flag that will request administrative rights. This command line flag tells our program to update and then exit instead of running the normal UI logic.</p>
        <p>Once we&rsquo;re in the &ldquo;Updater Mode&rdquo; we can start downloading the updated files to a temporary location. We do this first so if anything goes wrong the program will still work and on next run we can try again. After we have download all the files we then use the rename trick we talked about above to move the updated files.</p>

        <p>That&rsquo;s my updater in a nut shell. In part 2 I&rsquo;ll start showing some code on how I did this.</p>
        <p>(You can get a <a href="http://www.microsoft.com/click/services/Redirect2.ashx?CR_CC=200175595" target="_blank">90 day free trial for Windows Azure</a>, and yes I get stuff if you use my link but sadly not money)</p>
      