
        <p>Empty collections are more common then we may think. Error handlers may return them instead of passing the error along, Web APIs may return them when thereâ€™s nothing new, and if you do a search that has no results you get an empty collection. In building a Windows Phone app I had myself writing code the would return an empty list, but it seemed like a waste of memory. After all even though the collection has no objects there is overhead there that is because it could have objects. As such I built <em>EmptyCollection</em>, a class that looks like a collection, implements all the needed interfaces but cannot actually contain anything!</p>
        <p><code class="text/x-csharp">using System.Collections.Generic; <br />using System.Runtime.InteropServices; <br /><br />namespace System.Collections.ObjectModel <br />{ <br /> /// <br /> /// A special collection that is empty (useful for returning in errors when you cannot or do not want to return null). <br /> /// <br /> /// <br /> /// The type of the collection. <br /> /// <br /> /// <br /> /// All methods to add items to this "collection" really do nothing, while work with the list act as the there is an empty list. <br /> /// <br />#if !WINDOWS_PHONE &amp;&amp; !SILVERLIGHT <br /> [Serializable] <br />#endif <br /> [ComVisible(false)] <br /> public class EmptyCollection : IList, ICollection, IEnumerable, IList, ICollection, IEnumerable <br /> { <br /> #region IList Members <br /><br /> /// <br /> /// Searches for the specified object and returns the zero-based index of the first occurrence within the entire . <br /> /// <br /> ///<br /> /// The object to locate in the . The value can be null for reference types. <br /> /// <br /> /// <br /> /// The zero-based index of the first occurrence of within the entire , if found; otherwise, -1. <br /> /// <br /> public int IndexOf(T item) <br /> { <br /> return -1; <br /> } <br /><br /> /// <br /> /// Inserts an element into the at the specified index. <br /> /// <br /> ///<br /> /// The zero-based index at which should be inserted. <br /> /// <br /> ///<br /> /// The object to insert. The value can be null for reference types. <br /> /// <br /> public void Insert(int index, T item) <br /> { <br /> } <br /><br /> /// <br /> /// Removes the element at the specified index of the . <br /> /// <br /> ///<br /> /// The zero-based index of the element to remove. <br /> /// <br /> public void RemoveAt(int index) <br /> { <br /> } <br /><br /> /// <br /> /// Gets or sets the element at the specified index. <br /> /// <br /> ///<br /> /// The zero-based index of the element to get or set. <br /> /// <br /> /// <br /> /// The element at the specified index. <br /> /// <br /> /// <br /> /// is less than zero.-or- is equal to or greater than . <br /> /// <br /> /// <br /> /// <br /> /// accepts null as a valid value for reference types and allows duplicate elements. <br /> /// <br /> /// <br /> /// This property provides the ability to access a specific element in the collection by using the following syntax: myCollection[index]. <br /> /// <br /> /// <br /> /// The C# language uses the keyword to define the indexers instead of implementing the Item property. Visual Basic implements Item as a default property, which provides the same indexing functionality. <br /> /// <br /> /// <br /> /// Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation. <br /> /// <br /> /// <br /> public T this[int index] <br /> { <br /> get <br /> { <br />#if !WINDOWS_PHONE <br /> throw new ArgumentOutOfRangeException("index", index, "index is less than zero.-or-index is equal to or greater than Count."); <br />#else <br /> throw new ArgumentOutOfRangeException("index", "index is less than zero.-or-index is equal to or greater than Count."); <br />#endif <br /> } <br /> set <br /> { <br /> } <br /> } <br /><br /> #endregion <br /><br /> #region ICollection Members <br /><br /> /// <br /> /// Adds an object to the end of the . <br /> /// <br /> ///<br /> /// The object to be added to the end of the . The value can be null for reference types. <br /> /// <br /> /// <br /> /// <br /> /// accepts null as a valid value for reference types and allows duplicate elements. <br /> /// <br /> /// <br /> /// This method is an O(1) operation. <br /> /// <br /> /// <br /> public void Add(T item) <br /> { <br /> } <br /><br /> /// <br /> /// Removes all elements from the . <br /> /// <br /> /// <br /> /// is set to zero, and references to other objects from elements of the collection are also released. <br /> /// <br /> public void Clear() <br /> { <br /> } <br /><br /> /// <br /> /// Determines whether an element is in the . <br /> /// <br /> ///<br /> /// The object to locate in the . The value can be null for reference types. <br /> /// <br /> /// <br /> /// true if item is found in the ; otherwise, false. <br /> /// <br /> public bool Contains(T item) <br /> { <br /> return false; <br /> } <br /><br /> /// <br /> /// Copies the entire to a compatible one-dimensional , starting at the specified index of the target array. <br /> /// <br /> ///<br /> /// The one-dimensional that is the destination of the elements copied from . The must have zero-based indexing. <br /> /// <br /> ///<br /> /// The zero-based index in at which copying begins. <br /> /// <br /> public void CopyTo(T[] array, int arrayIndex) <br /> { <br /> } <br /><br /> /// <br /> /// Gets the number of elements actually contained in the . <br /> /// <br /> /// <br /> /// The number of elements actually contained in the . <br /> /// <br /> /// <br /> /// Retrieving the value of this property is an O(1) operation. <br /> /// <br /> public int Count <br /> { <br /> get <br /> { <br /> return 0; <br /> } <br /> } <br /><br /> /// <br /> /// Gets a value indicating whether the is read-only. <br /> /// <br /> public bool IsReadOnly <br /> { <br /> get <br /> { <br /> return true; <br /> } <br /> } <br /><br /> /// <br /> /// Removes the first occurrence of a specific object from the . <br /> /// <br /> ///<br /> /// The object to remove from the . The value can be null for reference types. <br /> /// <br /> /// <br /> /// true if is successfully removed; otherwise, false. This method also returns false if was not found in the original . <br /> /// <br /> public bool Remove(T item) <br /> { <br /> return false; <br /> } <br /><br /> #endregion <br /><br /> #region IEnumerable Members <br /><br /> /// <br /> /// An enumerator for empty collections. <br /> /// <br /> /// <br /> /// The type to enumerate over. <br /> /// <br /> /// <br /> /// Based on the code from <a href="http://msmvps.com/blogs/jon_skeet/archive/2010/12/24/reimplementing-linq-to-objects-part-5-empty.aspx" target="_blank">http://msmvps.com/blogs/jon_skeet/archive/2010/12/24/reimplementing-linq-to-objects-part-5-empty.aspx</a> <br /> /// <br /> private class EmptyEnumerable : IEnumerable, IEnumerator, IEnumerable, IEnumerator <br /> { <br /> /// <br /> /// For efficiency we cache per type. <br /> /// <br /> internal static IEnumerable Instance = new EmptyEnumerable(); <br /><br /> #region IEnumerable Members <br /><br /> /// <br /> /// Returns an enumerator that iterates through the . <br /> /// <br /> /// <br /> /// An for the . <br /> /// <br /> public IEnumerator GetEnumerator() <br /> { <br /> return this; <br /> } <br /><br /> #endregion <br /><br /> #region IEnumerable Members <br /><br /> /// <br /> /// Returns an enumerator that iterates through the . <br /> /// <br /> /// <br /> /// An for the . <br /> /// <br /> IEnumerator IEnumerable.GetEnumerator() <br /> { <br /> return this; <br /> } <br /><br /> #endregion <br /><br /> #region IEnumerator Members <br /><br /> /// <br /> /// Gets the element in the collection at the current position of the enumerator. <br /> /// <br /> /// <br /> /// The element in the collection at the current position of the enumerator. <br /> /// <br /> public TSource Current <br /> { <br /> get <br /> { <br /> throw new InvalidOperationException("There are no items"); <br /> } <br /> } <br /><br /> #endregion <br /><br /> #region IDisposable Members <br /><br /> /// <br /> /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. <br /> /// <br /> public void Dispose() <br /> { <br /> } <br /><br /> #endregion <br /><br /> #region IEnumerator Members <br /><br /> /// <br /> /// Gets the element in the collection at the current position of the enumerator. <br /> /// <br /> /// <br /> /// The element in the collection at the current position of the enumerator. <br /> /// <br /> object IEnumerator.Current <br /> { <br /> get <br /> { <br /> throw new InvalidOperationException("There are no items."); <br /> } <br /> } <br /><br /> /// <br /> /// Advances the enumerator to the next element of the collection. <br /> /// <br /> /// <br /> /// true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection. <br /> /// <br /> public bool MoveNext() <br /> { <br /> return false; <br /> } <br /><br /> /// <br /> /// Sets the enumerator to its initial position, which is before the first element in the collection. <br /> /// <br /> public void Reset() <br /> { <br /> } <br /><br /> #endregion <br /> } <br /><br /> /// <br /> /// Returns an enumerator that iterates through the . <br /> /// <br /> /// <br /> /// An for the . <br /> /// <br /> public IEnumerator GetEnumerator() <br /> { <br /> return EmptyEnumerable.Instance.GetEnumerator(); <br /> } <br /><br /> #endregion <br /><br /> #region IEnumerable Members <br /><br /> /// <br /> /// Returns an enumerator that iterates through a collection. <br /> /// <br /> /// <br /> /// An that can be used to iterate through the collection. <br /> /// <br /> IEnumerator IEnumerable.GetEnumerator() <br /> { <br /> return EmptyEnumerable.Instance.GetEnumerator(); <br /> } <br /><br /> #endregion <br /><br /> #region IList Members <br /><br /> /// <br /> /// Adds an item to the . <br /> /// <br /> ///<br /> /// The to add to the . <br /> /// <br /> /// <br /> /// The position into which the new element was inserted. <br /> /// <br /> public int Add(object value) <br /> { <br /> return -1; <br /> } <br /><br /> /// <br /> /// Determines whether the contains a specific value. <br /> /// <br /> ///<br /> /// The to locate in the . <br /> /// <br /> /// <br /> /// true if the is found in the ; otherwise, false. <br /> /// <br /> public bool Contains(object value) <br /> { <br /> return false; <br /> } <br /><br /> /// <br /> /// Determines the index of a specific item in the . <br /> /// <br /> ///<br /> /// The to locate in the . <br /> /// <br /> /// <br /> /// The index of if found in the list; otherwise, -1. <br /> /// <br /> public int IndexOf(object value) <br /> { <br /> return -1; <br /> } <br /><br /> /// <br /> /// Inserts an item into the at the specified index. <br /> /// <br /> ///<br /> /// The zero-based index at which should be inserted. <br /> /// <br /> ///<br /> /// The to insert into the . <br /> /// <br /> public void Insert(int index, object value) <br /> { <br /> } <br /><br /> /// <br /> /// Gets a value indicating whether the has a fixed size. <br /> /// <br /> public bool IsFixedSize <br /> { <br /> get <br /> { <br /> return true; <br /> } <br /> } <br /><br /> /// <br /> /// Removes the first occurrence of a specific object from the . <br /> /// <br /> ///<br /> /// The to remove from the . <br /> /// <br /> public void Remove(object value) <br /> { <br /> } <br /><br /> /// <br /> /// Gets or sets the element at the specified index. <br /> /// <br /> ///<br /> /// The zero-based index of the element to get or set. <br /> /// <br /> /// <br /> /// The element at the specified index. <br /> /// <br /> object IList.this[int index] <br /> { <br /> get <br /> { <br />#if !WINDOWS_PHONE <br /> throw new ArgumentOutOfRangeException("index", index, "index is less than zero.-or-index is equal to or greater than Count."); <br />#else <br /> throw new ArgumentOutOfRangeException("index", "index is less than zero.-or-index is equal to or greater than Count."); <br />#endif <br /> } <br /> set <br /> { <br /> } <br /> } <br /><br /> #endregion <br /><br /> #region ICollection Members <br /><br /> /// <br /> /// Copies the elements of the to an , starting at a particular index. <br /> /// <br /> ///<br /> /// The one-dimensional that is the destination of the elements copied from . The must have zero-based indexing. <br /> /// <br /> ///<br /> /// The zero-based index in at which copying begins. <br /> /// <br /> public void CopyTo(Array array, int index) <br /> { <br /> } <br /><br /> /// <br /> /// Gets a value indicating whether access to the is synchronized (thread safe). <br /> /// <br /> public bool IsSynchronized <br /> { <br /> get <br /> { <br /> return true; <br /> } <br /> } <br /><br /> /// <br /> /// Gets an object that can be used to synchronize access to the . <br /> /// <br /> public object SyncRoot <br /> { <br /> get <br /> { <br /> return this; <br /> } <br /> } <br /><br /> #endregion <br /><br /> #region Signleton-ness <br /><br /> /* <br /> * Since all instances of this class behave the same way I've added <br /> * this way to use it like a singleton. The advantage is that it is <br /> * only "newed" once. The downside is that even if you never need it <br /> * again there will be one in memory (though the footprint is small). <br /> * <br /> * NOTE: The singleton is on a per-Type bases. <br /> */ <br /><br /> /// <br /> /// The single &lt; to have. <br /> /// <br /> private static EmptyCollection singleton; <br /><br /> /// <br /> /// The single to have. <br /> /// <br /> [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1000:DoNotDeclareStaticMembersOnGenericTypes")] // Normally I'd agree with this but this is a weird class to start with so some things won't be "right". <br /> public static EmptyCollection Singleton <br /> { <br /> get <br /> { <br /> if (singleton == null) <br /> { <br /> singleton = new EmptyCollection(); <br /> } <br /> return singleton; <br /> } <br /> } <br /><br /> #endregion <br /> } <br />}</code></p>
      